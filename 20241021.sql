--INDEX
--테이블에 있는 데이터를 빠르게 검색하기 위한 용도로 나온 데이터베이스 객체
--테이블에 하나 이상의 컬럼으로 인덱스를 만들 수 있음
--오라클(ORACLE)에서는 기본적으로 테이블 기본키(PRIMARY KEY)로 인덱스가 설정되어 있음
--생성한 모든 인덱스 객체 조회
SELECT * FROM USER_INDEXES;

--CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명( 컬럼1, 컬럼2, ....)
-- [] : 선택사항 / UNIQUE : 유일인덱스 중복허용X
--특정 열에 대해 중복된 값을 허용하지 않아야 하는 경우 유일 인덱스를 설정,
--예를 들어, 이메일 주소와 같은 필드는 중복이 허용되지 않으므로 유일 인덱스를 생성

--PERSON 테이블에 사람이름으로 인덱스 지정
CREATE INDEX PERSON_PNAME_IDX ON PERSON(PNAME);
CREATE UNIQUE INDEX PERSON_PNAME_IDX ON PERSON(PNAME);
INSERT INTO PERSON VALUES('0005','홍길동',20); -- UNIQUE INDEX로 PNAME 중복값이 들어갈 수 없다.
INSERT INTO PERSON VALUES('0006','홍만동',20);
SELECT * FROM PERSON;
INSERT INTO PERSON VALUES('0006','훙만두',35);
DELETE FROM PERSON WHERE AGE = 35;

--인덱스 삭제
DROP UNIQUE INDEX PERSON_PNAME_IDX;

--리빌딩 작업
--데이터를 추가 삭제 수정등의 작업을 하다보면 트리가 한쪽으로 치우쳐지는 현상이 나기 때문
ALTER INDEX PERSON_PNAME_IDX REBUILD;

--CAR_SELL 테이블에 판매날짜에 인덱스 적용
CREATE INDEX CAR_SELL_SELL_DATE_IDX ON CAR_SELL(CAR_SELL_DATE);
DROP INDEX CAR_SELL_SELL_DATE_IDX;
SELECT * FROM CAR_SELL;

--사원 테이블에서 이름, 직급, 부서, 인덱스 적용
CREATE INDEX EMPLOYEE_IDX ON EMPLOYEE(EMP_NAME, POS_N O, DEPT_NO);


--SEQUENCE(시퀸스)
--자동으로 증가하는 순번을 반환하는 데이터베이스 객체
CREATE SEQUENCE NO_SEQ;
DROP SEQUENCE NO_SEQ;
--번호 뽑는법
SELECT NO_SEQ.NEXTVAL FROM DUAL;
SELECT NO_SEQ.CURRVAL FROM DUAL; -- 마지막에 뽑은 값 반환 : 시퀸스명.CURRVAL 
-- SEQUENCE를 생성하자마자 CURRVAL를 실행하면 실행한 값이 없기에 에러
SELECT * FROM USER_SEQUENCES;

--CREATE SEQUENCE 
--NO_SEQ : 시퀸스명
--INCREMENT BY 1 : 증가하는 간격
--START WITH 5 : 시작값
--MINVALUE 1 : 최소값
--MAXVALUE 99999999 : 최대값
--CYCLE/NOCYCLE : 사이클반복 / 반복X
--CACHE 20 NOORDER 

/*
시퀀스를 생성하는 기본 구문

CREATE SEQUENCE 시퀀스명
START WITH 1        -- 시작 값 (첫 번째 값)
INCREMENT BY 1      -- 증가 값 (얼마씩 증가할지)
MAXVALUE 100000     -- 최대 값
MINVALUE 1          -- 최소 값
CYCLE / NOCYCLE		-- 최대 값에 도달하면 다시 최소 값으로
CACHE 20 / NOCACHE;	-- 20개의 시퀀스를 미리 캐싱하여 성능을 높임 
*/

CREATE SEQUENCE TEST_SEQ
INCREMENT BY 2
START WITH 1
NOMINVALUE
NOMAXVALUE
NOCYCLE
NOCACHE; --NOCACHE
--
CREATE SEQUENCE TEST_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 20
CYCLE
CACHE 10; 

SELECT TEST_SEQ.NEXTVAL FROM DUAL;
DROP SEQUENCE TEST_SEQ;

SELECT * FROM USER_SEQUENCES;

--문제1. 기본 시퀸스 생성
--시퀸스 이름 SEQ_EMP_ID
--시작 값 1
--최대 값 9999
--증가 값 1
--캐시 값 20
CREATE SEQUENCE SEQ_EMP_ID
START WITH 1
MAXVALUE 9999
INCREMENT BY 1
CACHE 20;

DROP SEQUENCE SEQ_EMP_ID;

SELECT SEQ_EMP_ID.NEXTVAL FROM DUAL;

--문제2
--시퀸스 이름 : SEQ_DEPT_ID
--시작값 : 100
--최대값 : 110
--최소값 : 100
--증가값 : 1
--순환(CYCLE) : 사용

CREATE SEQUENCE SEQ_DEPT_ID
START WITH 100
MAXVALUE 110
MINVALUE 100
INCREMENT BY 1
CYCLE
NOCACHE;

SELECT SEQ_DEPT_ID.NEXTVAL FROM DUAL;
DROP SEQUENCE SEQ_DEPT_ID;

--시퀸스 이름 : SEQ_ORDER_NO
--시작 값 : 1000
--최소 값 : 500
--감소 값 : 10
--순환(CYCLE) : 미사용
CREATE SEQUENCE SEQ_ORDER_NO
START WITH 1000
MAXVALUE 1000
MINVALUE 500
INCREMENT BY -10;
--CYCLE;

SELECT
	SEQ_ORDER_NO.NEXTVAL
FROM
	DUAL;

DROP SEQUENCE SEQ_ORDER_NO;


-- SEQUENCE 예제 테스트
--1. SEQUENCE 생성
CREATE SEQUENCE SEQ_TEST_NO
START WITH 1 -- 시작 값
MAXVALUE 9999 -- 최대 값
MINVALUE 1 -- 최소 값
INCREMENT BY 1 -- 증가 값
CACHE 10 -- 메모리 미리 생성
NOCYCLE; --사이클(반복) NOCYCLE 사이클안함 CYCLE 사이클함

CREATE TABLE SEQ_TEST(
	SEQ_NO NUMBER PRIMARY KEY,
	SEQ_NAME VARCHAR2(30)
);

INSERT INTO SEQ_TEST VALUES(SEQ_TEST_NO.NEXTVAL,'테스트1'); -- INSERT 문 하나로 편하게 등록 가능

SELECT * FROM SEQ_TEST;
ROLLBACK; -- ROLLBACK 을 해도 SEQUENCE값은 롤백 되지 않음
DROP SEQUENCE SEQ_TEST_NO; -- SEQUENCE 를 삭제해도 기존 들어간 값은 있음

--VIEW(뷰)
--SQL에 하나의 이상의 테이블의 조회 결과를 저장한 "가상" 테이블 그래서 스토리지 용량(물리적공간)을 사용안한다.
--실제 데이터를 저장하지 않고, 쿼리의 결과를 미리 정의해 두어 필요할 때 재사용 할 수도 있다.
--뷰는 기본적으로 읽기 전용이지만, 조건에 따라 데이터를 업데이트가능 데이터 보안도 강화된다.

--VIEW 기본 생성방법
/*
CREATE VIEW 뷰이름 AS
SELECT 
	열1, 열2, ...
FROM 테이블명
WHERE 조건; 
	
CREATE OR REPLACE VIEW 뷰이름 AS ( OR REPLACE : 뷰를 수정하려면 CREATE OR REPLACE VIEW 명령어를 사용하여 기존 뷰를 대체할 수 있다)
조회할 SQL문(SELECT문)
*/

--VIEW 뷰 생성 권한 C##SCOTT에 부여
GRANT CREATE VIEW TO C##SCOTT;

--모든 관리자 권한 부여
--GRANT DBA TO 사용자명;

--학생 정보 조회, 학번, 이름, 학과명, 평점, 성별 조회하는 조회문 작성
SELECT 
	S.STD_NO, S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE , S.STD_GENDER 
FROM STUDENT S JOIN MAJOR M ON S.MAJOR_NO = M.MAJOR_NO; 

--위 조회문 VIEW로 만듬
CREATE OR REPLACE VIEW STUDENT_VIEW
AS 
SELECT 
	S.STD_NO, S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE , S.STD_GENDER 
FROM STUDENT S JOIN MAJOR M ON S.MAJOR_NO = M.MAJOR_NO; 

SELECT * FROM STUDENT_VIEW;

--성별 컬럼은 제거 후 뷰로 생성
--위 조회문 VIEW로 만듬
CREATE OR REPLACE VIEW STUDENT_VIEW
AS 
SELECT 
	S.STD_NO, S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE
FROM STUDENT S JOIN MAJOR M ON S.MAJOR_NO = M.MAJOR_NO; 

SELECT * FROM STUDENT_VIEW;

--학과별 인원수
SELECT 
	MAJOR_NAME ,
	COUNT(*)
FROM
	STUDENT_VIEW
GROUP BY
	MAJOR_NAME ;

--제약조건 CHECK  확인 TEST
CREATE TABLE TESTTABLE(
	T_NO CHAR(4)PRIMARY KEY,
	T_NAME VARCHAR2(30) NOT NULL,
	T_AVG NUMBER DEFAULT 1,
	CONSTRAINTS TEST_CHE CHECK(T_AVG > 10)
);

CREATE TABLE TESTTABLE(
	T_NO CHAR(4)PRIMARY KEY,
	T_NAME VARCHAR2(30) NOT NULL,
	T_AVG NUMBER DEFAULT 1
);
ALTER TABLE TESTTABLE ADD CONSTRAINTS TEST_CHK CHECK(T_AVG > 10);

INSERT INTO TESTTABLE VALUES('0001','테스트',9);
INSERT INTO TESTTABLE VALUES('0001','테스트', NULL);
INSERT INTO TESTTABLE VALUES('0002','테스트',11);
SELECT * FROM TESTTABLE;

DROP TABLE TESTTABLE;

--장학금을 받는 학생들의 정보를 저장하는 뷰 생성
--장학금 번호, 금액, 학번, 학생이름, 학과명, 성별, 평점
SELECT 
	SS.SCHOLARSHIP_NO ,
	SS.MONEY ,
	S.STD_NO ,
	S.STD_NAME ,
	M.MAJOR_NAME ,
	S.STD_GENDER ,
	S.STD_SCORE
FROM
	STUDENT S
JOIN MAJOR M ON
	S.MAJOR_NO = M.MAJOR_NO
JOIN STUDENT_SCHOLARSHIP SS ON
	S.STD_NO = SS.STD_NO
ORDER BY
	SS.SCHOLARSHIP_NO ASC;

--VIEW 생성
CREATE OR REPLACE
VIEW STUDENT_SCHOLARSHIP_VIEW AS
SELECT 
	SS.SCHOLARSHIP_NO ,
	SS.MONEY ,
	S.STD_NO ,
	S.STD_NAME ,
	M.MAJOR_NAME ,
	S.STD_GENDER ,
	S.STD_SCORE
FROM
	STUDENT S
JOIN MAJOR M ON
	S.MAJOR_NO = M.MAJOR_NO
JOIN STUDENT_SCHOLARSHIP SS ON
	S.STD_NO = SS.STD_NO
ORDER BY
	SS.SCHOLARSHIP_NO ASC;
	
SELECT * FROM STUDENT_SCHOLARSHIP_VIEW;